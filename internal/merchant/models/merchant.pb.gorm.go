package models

import (
	context "context"
	fmt "fmt"
	strings "strings"

	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	pq "github.com/lib/pq"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type MerchantAccountORM struct {
	AccountOnboardingDetails int32
	AccountOnboardingState   int32
	AccountType              int32
	Address                  *AddressORM `gorm:"foreignkey:MerchantAccountId;association_foreignkey:Id;preload:true"`
	AuthnAccountId           uint64
	Bio                      string
	BusinessEmail            string
	BusinessName             string
	BusinessType             string
	Country                  string
	DefaultCurrency          string
	EmployerId               uint64
	EstimateAnnualRevenue    string
	Headline                 string
	Id                       uint64
	IsActive                 bool
	ItemsOrServicesSold      []*ItemSoldORM `gorm:"foreignkey:MerchantAccountId;association_foreignkey:Id;preload:true"`
	Owners                   []*OwnerORM    `gorm:"foreignkey:MerchantAccountId;association_foreignkey:Id;preload:true"`
	PhoneNumber              string
	ShopSettings             *SettingsORM `gorm:"foreignkey:MerchantAccountId;association_foreignkey:Id;preload:true"`
	StripeAccountId          uint64
	StripeConnectedAccountId string
	Tags                     []*TagsORM `gorm:"foreignkey:MerchantAccountId;association_foreignkey:Id;preload:true"`
}

// TableName overrides the default tablename generated by GORM
func (MerchantAccountORM) TableName() string {
	return "merchant_accounts"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *MerchantAccount) ToORM(ctx context.Context) (MerchantAccountORM, error) {
	to := MerchantAccountORM{}
	var err error
	if prehook, ok := interface{}(m).(MerchantAccountWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Owners {
		if v != nil {
			if tempOwners, cErr := v.ToORM(ctx); cErr == nil {
				to.Owners = append(to.Owners, &tempOwners)
			} else {
				return to, cErr
			}
		} else {
			to.Owners = append(to.Owners, nil)
		}
	}
	to.BusinessName = m.BusinessName
	to.BusinessEmail = m.BusinessEmail
	to.EmployerId = m.EmployerId
	to.EstimateAnnualRevenue = m.EstimateAnnualRevenue
	if m.Address != nil {
		tempAddress, err := m.Address.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	for _, v := range m.ItemsOrServicesSold {
		if v != nil {
			if tempItemsOrServicesSold, cErr := v.ToORM(ctx); cErr == nil {
				to.ItemsOrServicesSold = append(to.ItemsOrServicesSold, &tempItemsOrServicesSold)
			} else {
				return to, cErr
			}
		} else {
			to.ItemsOrServicesSold = append(to.ItemsOrServicesSold, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	if m.ShopSettings != nil {
		tempShopSettings, err := m.ShopSettings.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.ShopSettings = &tempShopSettings
	}
	// Repeated type enum is not an ORMable message type
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToORM(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.StripeConnectedAccountId = m.StripeConnectedAccountId
	to.StripeAccountId = m.StripeAccountId
	to.AuthnAccountId = m.AuthnAccountId
	to.AccountOnboardingDetails = int32(m.AccountOnboardingDetails)
	to.AccountOnboardingState = int32(m.AccountOnboardingState)
	to.AccountType = int32(m.AccountType)
	to.IsActive = m.IsActive
	to.BusinessType = m.BusinessType
	to.Country = m.Country
	to.DefaultCurrency = m.DefaultCurrency
	if posthook, ok := interface{}(m).(MerchantAccountWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *MerchantAccountORM) ToPB(ctx context.Context) (MerchantAccount, error) {
	to := MerchantAccount{}
	var err error
	if prehook, ok := interface{}(m).(MerchantAccountWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	for _, v := range m.Owners {
		if v != nil {
			if tempOwners, cErr := v.ToPB(ctx); cErr == nil {
				to.Owners = append(to.Owners, &tempOwners)
			} else {
				return to, cErr
			}
		} else {
			to.Owners = append(to.Owners, nil)
		}
	}
	to.BusinessName = m.BusinessName
	to.BusinessEmail = m.BusinessEmail
	to.EmployerId = m.EmployerId
	to.EstimateAnnualRevenue = m.EstimateAnnualRevenue
	if m.Address != nil {
		tempAddress, err := m.Address.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Address = &tempAddress
	}
	for _, v := range m.ItemsOrServicesSold {
		if v != nil {
			if tempItemsOrServicesSold, cErr := v.ToPB(ctx); cErr == nil {
				to.ItemsOrServicesSold = append(to.ItemsOrServicesSold, &tempItemsOrServicesSold)
			} else {
				return to, cErr
			}
		} else {
			to.ItemsOrServicesSold = append(to.ItemsOrServicesSold, nil)
		}
	}
	// Repeated type enum is not an ORMable message type
	if m.ShopSettings != nil {
		tempShopSettings, err := m.ShopSettings.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.ShopSettings = &tempShopSettings
	}
	// Repeated type enum is not an ORMable message type
	to.Bio = m.Bio
	to.Headline = m.Headline
	to.PhoneNumber = m.PhoneNumber
	for _, v := range m.Tags {
		if v != nil {
			if tempTags, cErr := v.ToPB(ctx); cErr == nil {
				to.Tags = append(to.Tags, &tempTags)
			} else {
				return to, cErr
			}
		} else {
			to.Tags = append(to.Tags, nil)
		}
	}
	to.StripeConnectedAccountId = m.StripeConnectedAccountId
	to.StripeAccountId = m.StripeAccountId
	to.AuthnAccountId = m.AuthnAccountId
	to.AccountOnboardingDetails = OnboardingStatus(m.AccountOnboardingDetails)
	to.AccountOnboardingState = MerchantAccountState(m.AccountOnboardingState)
	to.AccountType = MerchantAccountType(m.AccountType)
	to.IsActive = m.IsActive
	to.BusinessType = m.BusinessType
	to.Country = m.Country
	to.DefaultCurrency = m.DefaultCurrency
	if posthook, ok := interface{}(m).(MerchantAccountWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type MerchantAccount the arg will be the target, the caller the one being converted from

// MerchantAccountBeforeToORM called before default ToORM code
type MerchantAccountWithBeforeToORM interface {
	BeforeToORM(context.Context, *MerchantAccountORM) error
}

// MerchantAccountAfterToORM called after default ToORM code
type MerchantAccountWithAfterToORM interface {
	AfterToORM(context.Context, *MerchantAccountORM) error
}

// MerchantAccountBeforeToPB called before default ToPB code
type MerchantAccountWithBeforeToPB interface {
	BeforeToPB(context.Context, *MerchantAccount) error
}

// MerchantAccountAfterToPB called after default ToPB code
type MerchantAccountWithAfterToPB interface {
	AfterToPB(context.Context, *MerchantAccount) error
}

type SettingsORM struct {
	Id                uint64
	MerchantAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (SettingsORM) TableName() string {
	return "settings"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Settings) ToORM(ctx context.Context) (SettingsORM, error) {
	to := SettingsORM{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type Policy is not an ORMable message type
	// Repeated type Policy is not an ORMable message type
	if posthook, ok := interface{}(m).(SettingsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SettingsORM) ToPB(ctx context.Context) (Settings, error) {
	to := Settings{}
	var err error
	if prehook, ok := interface{}(m).(SettingsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	// Repeated type Policy is not an ORMable message type
	// Repeated type Policy is not an ORMable message type
	if posthook, ok := interface{}(m).(SettingsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Settings the arg will be the target, the caller the one being converted from

// SettingsBeforeToORM called before default ToORM code
type SettingsWithBeforeToORM interface {
	BeforeToORM(context.Context, *SettingsORM) error
}

// SettingsAfterToORM called after default ToORM code
type SettingsWithAfterToORM interface {
	AfterToORM(context.Context, *SettingsORM) error
}

// SettingsBeforeToPB called before default ToPB code
type SettingsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Settings) error
}

// SettingsAfterToPB called after default ToPB code
type SettingsWithAfterToPB interface {
	AfterToPB(context.Context, *Settings) error
}

type ItemSoldORM struct {
	Id                uint64
	MerchantAccountId *uint64
	Type              int32
}

// TableName overrides the default tablename generated by GORM
func (ItemSoldORM) TableName() string {
	return "item_solds"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *ItemSold) ToORM(ctx context.Context) (ItemSoldORM, error) {
	to := ItemSoldORM{}
	var err error
	if prehook, ok := interface{}(m).(ItemSoldWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = int32(m.Type)
	if posthook, ok := interface{}(m).(ItemSoldWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ItemSoldORM) ToPB(ctx context.Context) (ItemSold, error) {
	to := ItemSold{}
	var err error
	if prehook, ok := interface{}(m).(ItemSoldWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Type = ItemSold_ItemsType(m.Type)
	if posthook, ok := interface{}(m).(ItemSoldWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type ItemSold the arg will be the target, the caller the one being converted from

// ItemSoldBeforeToORM called before default ToORM code
type ItemSoldWithBeforeToORM interface {
	BeforeToORM(context.Context, *ItemSoldORM) error
}

// ItemSoldAfterToORM called after default ToORM code
type ItemSoldWithAfterToORM interface {
	AfterToORM(context.Context, *ItemSoldORM) error
}

// ItemSoldBeforeToPB called before default ToPB code
type ItemSoldWithBeforeToPB interface {
	BeforeToPB(context.Context, *ItemSold) error
}

// ItemSoldAfterToPB called after default ToPB code
type ItemSoldWithAfterToPB interface {
	AfterToPB(context.Context, *ItemSold) error
}

type AddressORM struct {
	Address           string
	City              string
	Id                uint64
	Lattitude         string
	Longitude         string
	MerchantAccountId *uint64
	State             string
	Unit              string
	ZipCode           string
}

// TableName overrides the default tablename generated by GORM
func (AddressORM) TableName() string {
	return "addresses"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Address) ToORM(ctx context.Context) (AddressORM, error) {
	to := AddressORM{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.ZipCode = m.ZipCode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *AddressORM) ToPB(ctx context.Context) (Address, error) {
	to := Address{}
	var err error
	if prehook, ok := interface{}(m).(AddressWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.Address = m.Address
	to.Unit = m.Unit
	to.ZipCode = m.ZipCode
	to.City = m.City
	to.State = m.State
	to.Longitude = m.Longitude
	to.Lattitude = m.Lattitude
	if posthook, ok := interface{}(m).(AddressWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Address the arg will be the target, the caller the one being converted from

// AddressBeforeToORM called before default ToORM code
type AddressWithBeforeToORM interface {
	BeforeToORM(context.Context, *AddressORM) error
}

// AddressAfterToORM called after default ToORM code
type AddressWithAfterToORM interface {
	AfterToORM(context.Context, *AddressORM) error
}

// AddressBeforeToPB called before default ToPB code
type AddressWithBeforeToPB interface {
	BeforeToPB(context.Context, *Address) error
}

// AddressAfterToPB called after default ToPB code
type AddressWithAfterToPB interface {
	AfterToPB(context.Context, *Address) error
}

type OwnerORM struct {
	Country           string
	Email             string
	FirstName         string
	Id                uint64
	LastName          string
	MerchantAccountId *uint64
}

// TableName overrides the default tablename generated by GORM
func (OwnerORM) TableName() string {
	return "owners"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Owner) ToORM(ctx context.Context) (OwnerORM, error) {
	to := OwnerORM{}
	var err error
	if prehook, ok := interface{}(m).(OwnerWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Country = m.Country
	if posthook, ok := interface{}(m).(OwnerWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *OwnerORM) ToPB(ctx context.Context) (Owner, error) {
	to := Owner{}
	var err error
	if prehook, ok := interface{}(m).(OwnerWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.FirstName = m.FirstName
	to.LastName = m.LastName
	to.Email = m.Email
	to.Country = m.Country
	if posthook, ok := interface{}(m).(OwnerWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Owner the arg will be the target, the caller the one being converted from

// OwnerBeforeToORM called before default ToORM code
type OwnerWithBeforeToORM interface {
	BeforeToORM(context.Context, *OwnerORM) error
}

// OwnerAfterToORM called after default ToORM code
type OwnerWithAfterToORM interface {
	AfterToORM(context.Context, *OwnerORM) error
}

// OwnerBeforeToPB called before default ToPB code
type OwnerWithBeforeToPB interface {
	BeforeToPB(context.Context, *Owner) error
}

// OwnerAfterToPB called after default ToPB code
type OwnerWithAfterToPB interface {
	AfterToPB(context.Context, *Owner) error
}

type TagsORM struct {
	Id                uint64
	MerchantAccountId *uint64
	Metadata          pq.StringArray `gorm:"type:text[]"`
	TagDescription    string
	TagName           string
}

// TableName overrides the default tablename generated by GORM
func (TagsORM) TableName() string {
	return "tags"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Tags) ToORM(ctx context.Context) (TagsORM, error) {
	to := TagsORM{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *TagsORM) ToPB(ctx context.Context) (Tags, error) {
	to := Tags{}
	var err error
	if prehook, ok := interface{}(m).(TagsWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	to.TagName = m.TagName
	to.TagDescription = m.TagDescription
	if m.Metadata != nil {
		to.Metadata = make(pq.StringArray, len(m.Metadata))
		copy(to.Metadata, m.Metadata)
	}
	if posthook, ok := interface{}(m).(TagsWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Tags the arg will be the target, the caller the one being converted from

// TagsBeforeToORM called before default ToORM code
type TagsWithBeforeToORM interface {
	BeforeToORM(context.Context, *TagsORM) error
}

// TagsAfterToORM called after default ToORM code
type TagsWithAfterToORM interface {
	AfterToORM(context.Context, *TagsORM) error
}

// TagsBeforeToPB called before default ToPB code
type TagsWithBeforeToPB interface {
	BeforeToPB(context.Context, *Tags) error
}

// TagsAfterToPB called after default ToPB code
type TagsWithAfterToPB interface {
	AfterToPB(context.Context, *Tags) error
}

// DefaultCreateMerchantAccount executes a basic gorm create call
func DefaultCreateMerchantAccount(ctx context.Context, in *MerchantAccount, db *gorm.DB) (*MerchantAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type MerchantAccountORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadMerchantAccount(ctx context.Context, in *MerchantAccount, db *gorm.DB) (*MerchantAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &MerchantAccountORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := MerchantAccountORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(MerchantAccountORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type MerchantAccountORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteMerchantAccount(ctx context.Context, in *MerchantAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&MerchantAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type MerchantAccountORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteMerchantAccountSet(ctx context.Context, in []*MerchantAccount, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&MerchantAccountORM{})).(MerchantAccountORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&MerchantAccountORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&MerchantAccountORM{})).(MerchantAccountORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type MerchantAccountORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*MerchantAccount, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*MerchantAccount, *gorm.DB) error
}

// DefaultStrictUpdateMerchantAccount clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateMerchantAccount(ctx context.Context, in *MerchantAccount, db *gorm.DB) (*MerchantAccount, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateMerchantAccount")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &MerchantAccountORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	filterAddress := AddressORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterAddress.MerchantAccountId = new(uint64)
	*filterAddress.MerchantAccountId = ormObj.Id
	if err = db.Where(filterAddress).Delete(AddressORM{}).Error; err != nil {
		return nil, err
	}
	filterItemsOrServicesSold := ItemSoldORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterItemsOrServicesSold.MerchantAccountId = new(uint64)
	*filterItemsOrServicesSold.MerchantAccountId = ormObj.Id
	if err = db.Where(filterItemsOrServicesSold).Delete(ItemSoldORM{}).Error; err != nil {
		return nil, err
	}
	filterOwners := OwnerORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterOwners.MerchantAccountId = new(uint64)
	*filterOwners.MerchantAccountId = ormObj.Id
	if err = db.Where(filterOwners).Delete(OwnerORM{}).Error; err != nil {
		return nil, err
	}
	filterShopSettings := SettingsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterShopSettings.MerchantAccountId = new(uint64)
	*filterShopSettings.MerchantAccountId = ormObj.Id
	if err = db.Where(filterShopSettings).Delete(SettingsORM{}).Error; err != nil {
		return nil, err
	}
	filterTags := TagsORM{}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	filterTags.MerchantAccountId = new(uint64)
	*filterTags.MerchantAccountId = ormObj.Id
	if err = db.Where(filterTags).Delete(TagsORM{}).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type MerchantAccountORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchMerchantAccount executes a basic gorm update call with patch behavior
func DefaultPatchMerchantAccount(ctx context.Context, in *MerchantAccount, updateMask *field_mask.FieldMask, db *gorm.DB) (*MerchantAccount, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj MerchantAccount
	var err error
	if hook, ok := interface{}(&pbObj).(MerchantAccountWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadMerchantAccount(ctx, &MerchantAccount{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(MerchantAccountWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskMerchantAccount(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(MerchantAccountWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateMerchantAccount(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(MerchantAccountWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type MerchantAccountWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *MerchantAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *MerchantAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *MerchantAccount, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *MerchantAccount, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetMerchantAccount executes a bulk gorm update call with patch behavior
func DefaultPatchSetMerchantAccount(ctx context.Context, objects []*MerchantAccount, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*MerchantAccount, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*MerchantAccount, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchMerchantAccount(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskMerchantAccount patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskMerchantAccount(ctx context.Context, patchee *MerchantAccount, patcher *MerchantAccount, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*MerchantAccount, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedAddress bool
	var updatedShopSettings bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Owners" {
			patchee.Owners = patcher.Owners
			continue
		}
		if f == prefix+"BusinessName" {
			patchee.BusinessName = patcher.BusinessName
			continue
		}
		if f == prefix+"BusinessEmail" {
			patchee.BusinessEmail = patcher.BusinessEmail
			continue
		}
		if f == prefix+"EmployerId" {
			patchee.EmployerId = patcher.EmployerId
			continue
		}
		if f == prefix+"EstimateAnnualRevenue" {
			patchee.EstimateAnnualRevenue = patcher.EstimateAnnualRevenue
			continue
		}
		if !updatedAddress && strings.HasPrefix(f, prefix+"Address.") {
			updatedAddress = true
			if patcher.Address == nil {
				patchee.Address = nil
				continue
			}
			if patchee.Address == nil {
				patchee.Address = &Address{}
			}
			if o, err := DefaultApplyFieldMaskAddress(ctx, patchee.Address, patcher.Address, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Address.", db); err != nil {
				return nil, err
			} else {
				patchee.Address = o
			}
			continue
		}
		if f == prefix+"Address" {
			updatedAddress = true
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"ItemsOrServicesSold" {
			patchee.ItemsOrServicesSold = patcher.ItemsOrServicesSold
			continue
		}
		if f == prefix+"FulfillmentOptions" {
			patchee.FulfillmentOptions = patcher.FulfillmentOptions
			continue
		}
		if !updatedShopSettings && strings.HasPrefix(f, prefix+"ShopSettings.") {
			updatedShopSettings = true
			if patcher.ShopSettings == nil {
				patchee.ShopSettings = nil
				continue
			}
			if patchee.ShopSettings == nil {
				patchee.ShopSettings = &Settings{}
			}
			if o, err := DefaultApplyFieldMaskSettings(ctx, patchee.ShopSettings, patcher.ShopSettings, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"ShopSettings.", db); err != nil {
				return nil, err
			} else {
				patchee.ShopSettings = o
			}
			continue
		}
		if f == prefix+"ShopSettings" {
			updatedShopSettings = true
			patchee.ShopSettings = patcher.ShopSettings
			continue
		}
		if f == prefix+"SupportedCauses" {
			patchee.SupportedCauses = patcher.SupportedCauses
			continue
		}
		if f == prefix+"Bio" {
			patchee.Bio = patcher.Bio
			continue
		}
		if f == prefix+"Headline" {
			patchee.Headline = patcher.Headline
			continue
		}
		if f == prefix+"PhoneNumber" {
			patchee.PhoneNumber = patcher.PhoneNumber
			continue
		}
		if f == prefix+"Tags" {
			patchee.Tags = patcher.Tags
			continue
		}
		if f == prefix+"StripeConnectedAccountId" {
			patchee.StripeConnectedAccountId = patcher.StripeConnectedAccountId
			continue
		}
		if f == prefix+"StripeAccountId" {
			patchee.StripeAccountId = patcher.StripeAccountId
			continue
		}
		if f == prefix+"AuthnAccountId" {
			patchee.AuthnAccountId = patcher.AuthnAccountId
			continue
		}
		if f == prefix+"AccountOnboardingDetails" {
			patchee.AccountOnboardingDetails = patcher.AccountOnboardingDetails
			continue
		}
		if f == prefix+"AccountOnboardingState" {
			patchee.AccountOnboardingState = patcher.AccountOnboardingState
			continue
		}
		if f == prefix+"AccountType" {
			patchee.AccountType = patcher.AccountType
			continue
		}
		if f == prefix+"IsActive" {
			patchee.IsActive = patcher.IsActive
			continue
		}
		if f == prefix+"BusinessType" {
			patchee.BusinessType = patcher.BusinessType
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
		if f == prefix+"DefaultCurrency" {
			patchee.DefaultCurrency = patcher.DefaultCurrency
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListMerchantAccount executes a gorm list call
func DefaultListMerchantAccount(ctx context.Context, db *gorm.DB) ([]*MerchantAccount, error) {
	in := MerchantAccount{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &MerchantAccountORM{}, &MerchantAccount{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []MerchantAccountORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(MerchantAccountORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*MerchantAccount{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type MerchantAccountORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type MerchantAccountORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]MerchantAccountORM) error
}

// DefaultCreateSettings executes a basic gorm create call
func DefaultCreateSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &SettingsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SettingsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SettingsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SettingsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSettings(ctx context.Context, in *Settings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SettingsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSettingsSet(ctx context.Context, in []*Settings, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SettingsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SettingsORM{})).(SettingsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SettingsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Settings, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Settings, *gorm.DB) error
}

// DefaultStrictUpdateSettings clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSettings(ctx context.Context, in *Settings, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSettings")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SettingsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SettingsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSettings executes a basic gorm update call with patch behavior
func DefaultPatchSettings(ctx context.Context, in *Settings, updateMask *field_mask.FieldMask, db *gorm.DB) (*Settings, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Settings
	var err error
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSettings(ctx, &Settings{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSettings(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SettingsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSettings(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SettingsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SettingsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SettingsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Settings, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSettings executes a bulk gorm update call with patch behavior
func DefaultPatchSetSettings(ctx context.Context, objects []*Settings, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Settings, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Settings, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSettings(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSettings patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSettings(ctx context.Context, patchee *Settings, patcher *Settings, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Settings, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedPaymentDetails bool
	var updatedReturnPolicy bool
	var updatedShippingPolicy bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedPaymentDetails && strings.HasPrefix(f, prefix+"PaymentDetails.") {
			if patcher.PaymentDetails == nil {
				patchee.PaymentDetails = nil
				continue
			}
			if patchee.PaymentDetails == nil {
				patchee.PaymentDetails = &Settings_PaymentDetails{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"PaymentDetails."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.PaymentDetails, patchee.PaymentDetails, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"PaymentDetails" {
			updatedPaymentDetails = true
			patchee.PaymentDetails = patcher.PaymentDetails
			continue
		}
		if f == prefix+"ShopPolicy" {
			patchee.ShopPolicy = patcher.ShopPolicy
			continue
		}
		if f == prefix+"PrivacyPolicy" {
			patchee.PrivacyPolicy = patcher.PrivacyPolicy
			continue
		}
		if !updatedReturnPolicy && strings.HasPrefix(f, prefix+"ReturnPolicy.") {
			if patcher.ReturnPolicy == nil {
				patchee.ReturnPolicy = nil
				continue
			}
			if patchee.ReturnPolicy == nil {
				patchee.ReturnPolicy = &ReturnPolicy{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ReturnPolicy."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ReturnPolicy, patchee.ReturnPolicy, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ReturnPolicy" {
			updatedReturnPolicy = true
			patchee.ReturnPolicy = patcher.ReturnPolicy
			continue
		}
		if !updatedShippingPolicy && strings.HasPrefix(f, prefix+"ShippingPolicy.") {
			if patcher.ShippingPolicy == nil {
				patchee.ShippingPolicy = nil
				continue
			}
			if patchee.ShippingPolicy == nil {
				patchee.ShippingPolicy = &ShippingPolicy{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"ShippingPolicy."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.ShippingPolicy, patchee.ShippingPolicy, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"ShippingPolicy" {
			updatedShippingPolicy = true
			patchee.ShippingPolicy = patcher.ShippingPolicy
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSettings executes a gorm list call
func DefaultListSettings(ctx context.Context, db *gorm.DB) ([]*Settings, error) {
	in := Settings{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SettingsORM{}, &Settings{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SettingsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SettingsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Settings{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SettingsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SettingsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SettingsORM) error
}

// DefaultCreateItemSold executes a basic gorm create call
func DefaultCreateItemSold(ctx context.Context, in *ItemSold, db *gorm.DB) (*ItemSold, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ItemSoldORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadItemSold(ctx context.Context, in *ItemSold, db *gorm.DB) (*ItemSold, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &ItemSoldORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ItemSoldORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ItemSoldORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ItemSoldORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteItemSold(ctx context.Context, in *ItemSold, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ItemSoldORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ItemSoldORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteItemSoldSet(ctx context.Context, in []*ItemSold, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ItemSoldORM{})).(ItemSoldORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ItemSoldORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ItemSoldORM{})).(ItemSoldORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ItemSoldORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*ItemSold, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*ItemSold, *gorm.DB) error
}

// DefaultStrictUpdateItemSold clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateItemSold(ctx context.Context, in *ItemSold, db *gorm.DB) (*ItemSold, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateItemSold")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ItemSoldORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ItemSoldORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchItemSold executes a basic gorm update call with patch behavior
func DefaultPatchItemSold(ctx context.Context, in *ItemSold, updateMask *field_mask.FieldMask, db *gorm.DB) (*ItemSold, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj ItemSold
	var err error
	if hook, ok := interface{}(&pbObj).(ItemSoldWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadItemSold(ctx, &ItemSold{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ItemSoldWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskItemSold(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ItemSoldWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateItemSold(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ItemSoldWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ItemSoldWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *ItemSold, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *ItemSold, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *ItemSold, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *ItemSold, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetItemSold executes a bulk gorm update call with patch behavior
func DefaultPatchSetItemSold(ctx context.Context, objects []*ItemSold, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*ItemSold, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*ItemSold, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchItemSold(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskItemSold patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskItemSold(ctx context.Context, patchee *ItemSold, patcher *ItemSold, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*ItemSold, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Type" {
			patchee.Type = patcher.Type
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListItemSold executes a gorm list call
func DefaultListItemSold(ctx context.Context, db *gorm.DB) ([]*ItemSold, error) {
	in := ItemSold{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &ItemSoldORM{}, &ItemSold{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ItemSoldORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ItemSoldORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*ItemSold{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ItemSoldORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ItemSoldORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ItemSoldORM) error
}

// DefaultCreateAddress executes a basic gorm create call
func DefaultCreateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &AddressORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := AddressORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(AddressORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type AddressORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteAddress(ctx context.Context, in *Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type AddressORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteAddressSet(ctx context.Context, in []*Address, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&AddressORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&AddressORM{})).(AddressORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type AddressORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Address, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Address, *gorm.DB) error
}

// DefaultStrictUpdateAddress clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateAddress(ctx context.Context, in *Address, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateAddress")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &AddressORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type AddressORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchAddress executes a basic gorm update call with patch behavior
func DefaultPatchAddress(ctx context.Context, in *Address, updateMask *field_mask.FieldMask, db *gorm.DB) (*Address, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Address
	var err error
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadAddress(ctx, &Address{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskAddress(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(AddressWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateAddress(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(AddressWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type AddressWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type AddressWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Address, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetAddress executes a bulk gorm update call with patch behavior
func DefaultPatchSetAddress(ctx context.Context, objects []*Address, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Address, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Address, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchAddress(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskAddress patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskAddress(ctx context.Context, patchee *Address, patcher *Address, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Address, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"Address" {
			patchee.Address = patcher.Address
			continue
		}
		if f == prefix+"Unit" {
			patchee.Unit = patcher.Unit
			continue
		}
		if f == prefix+"ZipCode" {
			patchee.ZipCode = patcher.ZipCode
			continue
		}
		if f == prefix+"City" {
			patchee.City = patcher.City
			continue
		}
		if f == prefix+"State" {
			patchee.State = patcher.State
			continue
		}
		if f == prefix+"Longitude" {
			patchee.Longitude = patcher.Longitude
			continue
		}
		if f == prefix+"Lattitude" {
			patchee.Lattitude = patcher.Lattitude
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListAddress executes a gorm list call
func DefaultListAddress(ctx context.Context, db *gorm.DB) ([]*Address, error) {
	in := Address{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &AddressORM{}, &Address{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []AddressORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(AddressORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Address{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type AddressORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type AddressORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]AddressORM) error
}

// DefaultCreateOwner executes a basic gorm create call
func DefaultCreateOwner(ctx context.Context, in *Owner, db *gorm.DB) (*Owner, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type OwnerORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadOwner(ctx context.Context, in *Owner, db *gorm.DB) (*Owner, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &OwnerORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := OwnerORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(OwnerORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type OwnerORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteOwner(ctx context.Context, in *Owner, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&OwnerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type OwnerORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteOwnerSet(ctx context.Context, in []*Owner, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&OwnerORM{})).(OwnerORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&OwnerORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&OwnerORM{})).(OwnerORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type OwnerORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Owner, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Owner, *gorm.DB) error
}

// DefaultStrictUpdateOwner clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateOwner(ctx context.Context, in *Owner, db *gorm.DB) (*Owner, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateOwner")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &OwnerORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type OwnerORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchOwner executes a basic gorm update call with patch behavior
func DefaultPatchOwner(ctx context.Context, in *Owner, updateMask *field_mask.FieldMask, db *gorm.DB) (*Owner, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Owner
	var err error
	if hook, ok := interface{}(&pbObj).(OwnerWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadOwner(ctx, &Owner{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(OwnerWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskOwner(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(OwnerWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateOwner(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(OwnerWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type OwnerWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Owner, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OwnerWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Owner, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OwnerWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Owner, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type OwnerWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Owner, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetOwner executes a bulk gorm update call with patch behavior
func DefaultPatchSetOwner(ctx context.Context, objects []*Owner, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Owner, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Owner, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchOwner(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskOwner patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskOwner(ctx context.Context, patchee *Owner, patcher *Owner, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Owner, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"FirstName" {
			patchee.FirstName = patcher.FirstName
			continue
		}
		if f == prefix+"LastName" {
			patchee.LastName = patcher.LastName
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Country" {
			patchee.Country = patcher.Country
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListOwner executes a gorm list call
func DefaultListOwner(ctx context.Context, db *gorm.DB) ([]*Owner, error) {
	in := Owner{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &OwnerORM{}, &Owner{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []OwnerORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(OwnerORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Owner{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type OwnerORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type OwnerORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]OwnerORM) error
}

// DefaultCreateTags executes a basic gorm create call
func DefaultCreateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if db, err = gorm1.ApplyFieldSelection(ctx, db, nil, &TagsORM{}); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := TagsORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(TagsORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type TagsORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteTags(ctx context.Context, in *Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type TagsORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteTagsSet(ctx context.Context, in []*Tags, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []uint64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&TagsORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&TagsORM{})).(TagsORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type TagsORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Tags, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Tags, *gorm.DB) error
}

// DefaultStrictUpdateTags clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateTags(ctx context.Context, in *Tags, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateTags")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &TagsORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type TagsORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchTags executes a basic gorm update call with patch behavior
func DefaultPatchTags(ctx context.Context, in *Tags, updateMask *field_mask.FieldMask, db *gorm.DB) (*Tags, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Tags
	var err error
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadTags(ctx, &Tags{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskTags(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(TagsWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateTags(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(TagsWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type TagsWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type TagsWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Tags, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetTags executes a bulk gorm update call with patch behavior
func DefaultPatchSetTags(ctx context.Context, objects []*Tags, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Tags, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Tags, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchTags(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskTags patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskTags(ctx context.Context, patchee *Tags, patcher *Tags, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Tags, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if f == prefix+"TagName" {
			patchee.TagName = patcher.TagName
			continue
		}
		if f == prefix+"TagDescription" {
			patchee.TagDescription = patcher.TagDescription
			continue
		}
		if f == prefix+"Metadata" {
			patchee.Metadata = patcher.Metadata
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListTags executes a gorm list call
func DefaultListTags(ctx context.Context, db *gorm.DB) ([]*Tags, error) {
	in := Tags{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &TagsORM{}, &Tags{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []TagsORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(TagsORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Tags{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type TagsORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type TagsORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]TagsORM) error
}
